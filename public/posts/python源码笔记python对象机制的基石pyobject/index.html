<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Python源码笔记——Python对象机制的基石【PyObject】 | lei的博客</title>
<meta name="keywords" content="Python">
<meta name="description" content="
所有源码均基于Python 3.11.2

1.PyObject定义


1
2
3
4
5
6
7
8


// 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。
// 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。
typedef struct _object {
		_PyObject_HEAD_EXTRA  // 定义指针以支持所有活动堆对象的双向链表refchain

		Py_ssize_t ob_refcnt;
    PyTypeObject *ob_type;
} PyObject;


Python通过ob_refcnt字段实现基于引用计数的垃圾回收机制。对于某一个对象A，当有一个新的PyObject*引用A对象时，A的引用计数会增加1，当这个PyObject*引用被删除时，A的引用计数应当减1，当此字段为0时，进行垃圾回收（不一定会释放内存空间，Python中还有缓存机制）。
_PyObject_HEAD_EXTRA是一个宏，当编译Python时指定参数--with-trace-refs，那么Py_TRACE_REFS 会被定义。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


#ifdef Py_TRACE_REFS
/* Define pointers to support a doubly-linked list of all live heap objects. */
#define _PyObject_HEAD_EXTRA            \
    PyObject *_ob_next;           \
    PyObject *_ob_prev;

#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,

#else
#  define _PyObject_HEAD_EXTRA
#  define _PyObject_EXTRA_INIT
#endif


ob_type是一个结构体，对应着Python内部的一种特殊的对象，用来指定一个对象类型的类型对象。">
<meta name="author" content="">
<link rel="canonical" href="https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3pyobject/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.263bac85f191a9f304e91b8bb5ec997c174abef0bec446591945462e5fdff366.css" integrity="sha256-JjushfGRqfME6RuLteyZfBdKvvC&#43;xEZZGUVGLl/f82Y=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zzhaolei.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zzhaolei.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zzhaolei.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zzhaolei.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zzhaolei.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3pyobject/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3pyobject/">
  <meta property="og:site_name" content="lei的博客">
  <meta property="og:title" content="Python源码笔记——Python对象机制的基石【PyObject】">
  <meta property="og:description" content=" 所有源码均基于Python 3.11.2
1.PyObject定义 1 2 3 4 5 6 7 8 // 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。 // 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。 typedef struct _object { _PyObject_HEAD_EXTRA // 定义指针以支持所有活动堆对象的双向链表refchain Py_ssize_t ob_refcnt; PyTypeObject *ob_type; } PyObject; Python通过ob_refcnt字段实现基于引用计数的垃圾回收机制。对于某一个对象A，当有一个新的PyObject*引用A对象时，A的引用计数会增加1，当这个PyObject*引用被删除时，A的引用计数应当减1，当此字段为0时，进行垃圾回收（不一定会释放内存空间，Python中还有缓存机制）。
_PyObject_HEAD_EXTRA是一个宏，当编译Python时指定参数--with-trace-refs，那么Py_TRACE_REFS 会被定义。
1 2 3 4 5 6 7 8 9 10 11 12 #ifdef Py_TRACE_REFS /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \ PyObject *_ob_next; \ PyObject *_ob_prev; #define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL, #else # define _PyObject_HEAD_EXTRA # define _PyObject_EXTRA_INIT #endif ob_type是一个结构体，对应着Python内部的一种特殊的对象，用来指定一个对象类型的类型对象。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-04-07T13:43:34+08:00">
    <meta property="article:modified_time" content="2023-04-07T13:43:34+08:00">
    <meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python源码笔记——Python对象机制的基石【PyObject】">
<meta name="twitter:description" content="
所有源码均基于Python 3.11.2

1.PyObject定义


1
2
3
4
5
6
7
8


// 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。
// 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。
typedef struct _object {
		_PyObject_HEAD_EXTRA  // 定义指针以支持所有活动堆对象的双向链表refchain

		Py_ssize_t ob_refcnt;
    PyTypeObject *ob_type;
} PyObject;


Python通过ob_refcnt字段实现基于引用计数的垃圾回收机制。对于某一个对象A，当有一个新的PyObject*引用A对象时，A的引用计数会增加1，当这个PyObject*引用被删除时，A的引用计数应当减1，当此字段为0时，进行垃圾回收（不一定会释放内存空间，Python中还有缓存机制）。
_PyObject_HEAD_EXTRA是一个宏，当编译Python时指定参数--with-trace-refs，那么Py_TRACE_REFS 会被定义。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12


#ifdef Py_TRACE_REFS
/* Define pointers to support a doubly-linked list of all live heap objects. */
#define _PyObject_HEAD_EXTRA            \
    PyObject *_ob_next;           \
    PyObject *_ob_prev;

#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,

#else
#  define _PyObject_HEAD_EXTRA
#  define _PyObject_EXTRA_INIT
#endif


ob_type是一个结构体，对应着Python内部的一种特殊的对象，用来指定一个对象类型的类型对象。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://zzhaolei.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Python源码笔记——Python对象机制的基石【PyObject】",
      "item": "https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3pyobject/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Python源码笔记——Python对象机制的基石【PyObject】",
  "name": "Python源码笔记——Python对象机制的基石【PyObject】",
  "description": " 所有源码均基于Python 3.11.2\n1.PyObject定义 1 2 3 4 5 6 7 8 // 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。 // 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。 typedef struct _object { _PyObject_HEAD_EXTRA // 定义指针以支持所有活动堆对象的双向链表refchain Py_ssize_t ob_refcnt; PyTypeObject *ob_type; } PyObject; Python通过ob_refcnt字段实现基于引用计数的垃圾回收机制。对于某一个对象A，当有一个新的PyObject*引用A对象时，A的引用计数会增加1，当这个PyObject*引用被删除时，A的引用计数应当减1，当此字段为0时，进行垃圾回收（不一定会释放内存空间，Python中还有缓存机制）。\n_PyObject_HEAD_EXTRA是一个宏，当编译Python时指定参数--with-trace-refs，那么Py_TRACE_REFS 会被定义。\n1 2 3 4 5 6 7 8 9 10 11 12 #ifdef Py_TRACE_REFS /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \\ PyObject *_ob_next; \\ PyObject *_ob_prev; #define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL, #else # define _PyObject_HEAD_EXTRA # define _PyObject_EXTRA_INIT #endif ob_type是一个结构体，对应着Python内部的一种特殊的对象，用来指定一个对象类型的类型对象。\n",
  "keywords": [
    "Python"
  ],
  "articleBody": " 所有源码均基于Python 3.11.2\n1.PyObject定义 1 2 3 4 5 6 7 8 // 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。 // 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。 typedef struct _object { _PyObject_HEAD_EXTRA // 定义指针以支持所有活动堆对象的双向链表refchain Py_ssize_t ob_refcnt; PyTypeObject *ob_type; } PyObject; Python通过ob_refcnt字段实现基于引用计数的垃圾回收机制。对于某一个对象A，当有一个新的PyObject*引用A对象时，A的引用计数会增加1，当这个PyObject*引用被删除时，A的引用计数应当减1，当此字段为0时，进行垃圾回收（不一定会释放内存空间，Python中还有缓存机制）。\n_PyObject_HEAD_EXTRA是一个宏，当编译Python时指定参数--with-trace-refs，那么Py_TRACE_REFS 会被定义。\n1 2 3 4 5 6 7 8 9 10 11 12 #ifdef Py_TRACE_REFS /* Define pointers to support a doubly-linked list of all live heap objects. */ #define _PyObject_HEAD_EXTRA \\ PyObject *_ob_next; \\ PyObject *_ob_prev; #define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL, #else # define _PyObject_HEAD_EXTRA # define _PyObject_EXTRA_INIT #endif ob_type是一个结构体，对应着Python内部的一种特殊的对象，用来指定一个对象类型的类型对象。\n2.定长对象和变长对象 在Python中除了PyObject结构体之外，还有PyVarObject结构体。\n1 2 3 4 5 6 #define PyObject_VAR_HEAD PyVarObject ob_base; typedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; 我们把不包含可变长度数据的对象称为定长对象，而字符串对象、整数对象这样包含可变长度数据的对象称为变长对象。它们的区别在于定长对象的不同对象占用的内存大小是一样的，而变长对象的不同对象占用的内存可能是不一样的。\n变长对象通常是容器类型，ob_size这个字段实际上就是指明了变长对象中一共容纳了多少个元素，而不是字节的数量。\n为什么整数对象是可变长度对象呢？因为在Python中，整数对象是没有位数限制的，这是一个大整数对象的实现，在整数对象的结构体PyLongObject定义中，使用到了PyVarObject，用于指定size。 3.为什么PyObject要定义在每一个Python对象的最开始字节中 从PyVarObject的定义可以看出，PyVarObject只是PyObject的一个扩展而已。因此，对于任何一个PyVarObject，其所占用的内存，开始部分的字节的意义和PyObject是一样的。换句话说，在Python内部，每一个对象都拥有相同的对象头部。这就使得在Python中，对对象的引用变得非常统一，我们只需要用一个PyObject*指针就可以引用任意一个对象，而不论该对象实际是一个什么对象。\n这是一个简单的转换示例程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include struct PyObject { int _ob; int _type; }; struct PyVarObject { struct PyObject ob_base; int ob_size; }; // List结构体 struct PyListObject { struct PyVarObject ob_var; int ob_item; }; // Python中的双向链表 struct refchain { struct PyObject *prev; struct PyObject *next; }; int main() { struct PyListObject list = { .ob_var.ob_size = 2, .ob_var.ob_base._ob = 0, .ob_var.ob_base._type = 1, .ob_item = 3, }; struct PyListObject *p_list = \u0026list; // Object和List可以通过指针进行强转 struct PyObject *p_ob = (struct PyObject *)(p_list); printf(\"Object: %d\\n\", p_ob-\u003e_ob); // Object: 0 struct PyListObject *p_list1 = (struct PyListObject *)(p_ob); printf(\"List: %d\\n\", p_list1-\u003eob_item); // List: 3 return 0; } 4.类型对象 当在内存中分配空间，创建对象的时候，我们需要知道申请多大的空间。显然，这不是一个定值，因为不同的对象，需要不同的空间，一个整数对象和一个字符串对象所需的空间肯定不同。\n在PyObject中，PyTypeObject *ob_type字段就表示类型对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef struct _typeobject { PyObject_VAR_HEAD const char *tp_name; /* 用于打印，格式为\".\" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; ... /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; ... hashfunc tp_hash; ternaryfunc tp_call; } PyTypeObject; 一个PyTypeObject对象就是Python中面向对象理论中的”类“的实现。\n在PyTypeObject的定义中，有三组非常重要的操作族，tp_as_number、tp_as_sequence、tp_as_mapping。它们分别指向PyNumberMethods、PySequenceMethods、PyMappingMethods函数族。\n1 2 3 4 5 6 7 typedef PyObject * (*binaryfunc)(PyObject *, PyObject *); typedef struct { binaryfunc nb_add; binaryfunc nb_subtract; ... } PyNumberMethods; 在PyNumberMethods中，定义了一个数值对象应该支持的操作。\n对于一种类型来说，它完全可以同时定义三个函数中的所有操作。即一个对象既可以表现出数值对象的特性，也可以表现出map对象的特性。\n1 2 3 4 5 6 7 8 9 10 \u003e\u003e\u003e class Int(int): ... def __getitem__(self, key: str) -\u003e str: ... return key + str(self) ... \u003e\u003e\u003e a = Int(1) \u003e\u003e\u003e b = Int(2) \u003e\u003e\u003e print(a + b) 3 \u003e\u003e\u003e a[\"key\"] 'key1' a是一个数值类型的对象实例，我们通过重写__getitem__方法，可以视为指定了Int在Python内部对应的PyTypeObject对象的tp_as_mapping.mp_subcript操作，最终Int的实例对象可以表现得像map对象一样。原因就是PyTypeObject允许一种类型同时指定三种不同对象的行为特性。\n5.引用计数 类型对象是不会被析构的，因为没有人回去增加和减少类型对象的引用计数，Python程序启动后，类型对象就已经定义好了。\n在每个对象创建的时候，Python会使用_Py_NewReference(op)宏来将对象的引用计数初始化为1。\n当对象的引用计数等于0时，Python不一定会将内存空间释放，而是会采用内存缓冲池的机制，将不使用的对象缓存起来，增加Python的执行效率。我们后续介绍Python的缓冲机制。\n",
  "wordCount" : "403",
  "inLanguage": "zh",
  "datePublished": "2023-04-07T13:43:34+08:00",
  "dateModified": "2023-04-07T13:43:34+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E5%AF%B9%E8%B1%A1%E6%9C%BA%E5%88%B6%E7%9A%84%E5%9F%BA%E7%9F%B3pyobject/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "lei的博客",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zzhaolei.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zzhaolei.github.io/" accesskey="h" title="lei的博客 (Alt + H)">lei的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zzhaolei.github.io/archive/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://zzhaolei.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://zzhaolei.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Python源码笔记——Python对象机制的基石【PyObject】
    </h1>
    <div class="post-meta"><span title='2023-04-07 13:43:34 +0800 CST'>四月 7, 2023</span>&nbsp;·&nbsp;2 分钟

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1pyobject%e5%ae%9a%e4%b9%89" aria-label="1.PyObject定义">1.PyObject定义</a></li>
                <li>
                    <a href="#2%e5%ae%9a%e9%95%bf%e5%af%b9%e8%b1%a1%e5%92%8c%e5%8f%98%e9%95%bf%e5%af%b9%e8%b1%a1" aria-label="2.定长对象和变长对象">2.定长对象和变长对象</a></li>
                <li>
                    <a href="#3%e4%b8%ba%e4%bb%80%e4%b9%88pyobject%e8%a6%81%e5%ae%9a%e4%b9%89%e5%9c%a8%e6%af%8f%e4%b8%80%e4%b8%aapython%e5%af%b9%e8%b1%a1%e7%9a%84%e6%9c%80%e5%bc%80%e5%a7%8b%e5%ad%97%e8%8a%82%e4%b8%ad" aria-label="3.为什么PyObject要定义在每一个Python对象的最开始字节中">3.为什么PyObject要定义在每一个Python对象的最开始字节中</a></li>
                <li>
                    <a href="#4%e7%b1%bb%e5%9e%8b%e5%af%b9%e8%b1%a1" aria-label="4.类型对象">4.类型对象</a></li>
                <li>
                    <a href="#5%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0" aria-label="5.引用计数">5.引用计数</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><blockquote>
<p>所有源码均基于<code>Python 3.11.2</code></p>
</blockquote>
<h2 id="1pyobject定义">1.PyObject定义<a hidden class="anchor" aria-hidden="true" href="#1pyobject定义">#</a></h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// 实际上没有任何东西被声明为PyObject，但是每个指向Python对象的指针都可以转换为PyObject*。
</span></span></span><span class="line"><span class="cl"><span class="c1">// 这是手动模拟的继承。同样的，每个指向可变大小的Python对象的指针也可以转换为PyObject*，此外，也可以转换为PyVarObject*。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_object</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">_PyObject_HEAD_EXTRA</span>  <span class="c1">// 定义指针以支持所有活动堆对象的双向链表refchain
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">		<span class="n">Py_ssize_t</span> <span class="n">ob_refcnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">ob_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PyObject</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>Python</code>通过<code>ob_refcnt</code>字段实现基于引用计数的垃圾回收机制。对于某一个<code>对象A</code>，当有一个新的<code>PyObject*</code>引用<code>A对象</code>时，<code>A</code>的引用计数会增加<code>1</code>，当这个<code>PyObject*</code>引用被删除时，<code>A</code>的引用计数应当减<code>1</code>，当此字段为<code>0</code>时，进行垃圾回收（不一定会释放内存空间，<code>Python</code>中还有缓存机制）。</p>
<p><code>_PyObject_HEAD_EXTRA</code>是一个宏，当编译<code>Python</code>时指定参数<code>--with-trace-refs</code>，那么<code>Py_TRACE_REFS</code> 会被定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#ifdef Py_TRACE_REFS
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="cm">/* Define pointers to support a doubly-linked list of all live heap objects. */</span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _PyObject_HEAD_EXTRA            \
</span></span></span><span class="line"><span class="cl"><span class="cp">    PyObject *_ob_next;           \
</span></span></span><span class="line"><span class="cl"><span class="cp">    PyObject *_ob_prev;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#define _PyObject_EXTRA_INIT _Py_NULL, _Py_NULL,
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp">#  define _PyObject_HEAD_EXTRA
</span></span></span><span class="line"><span class="cl"><span class="cp">#  define _PyObject_EXTRA_INIT
</span></span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><code>ob_type</code>是一个结构体，对应着<code>Python</code>内部的一种特殊的对象，用来指定一个对象类型的类型对象。</p>
<h2 id="2定长对象和变长对象">2.定长对象和变长对象<a hidden class="anchor" aria-hidden="true" href="#2定长对象和变长对象">#</a></h2>
<p>在Python中除了<code>PyObject</code>结构体之外，还有<code>PyVarObject</code>结构体。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define PyObject_VAR_HEAD      PyVarObject ob_base;
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyObject</span> <span class="n">ob_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Py_ssize_t</span> <span class="n">ob_size</span><span class="p">;</span> <span class="cm">/* Number of items in variable part */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PyVarObject</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们把不包含可变长度数据的对象称为定长对象，而字符串对象、整数对象这样包含可变长度数据的对象称为变长对象。它们的区别在于定长对象的不同对象占用的内存大小是一样的，而变长对象的不同对象占用的内存可能是不一样的。</p>
<p>变长对象通常是容器类型，<code>ob_size</code>这个字段实际上就是指明了变长对象中一共容纳了多少个元素，而不是字节的数量。</p>
<ul>
<li>为什么整数对象是可变长度对象呢？因为在Python中，整数对象是没有位数限制的，这是一个大整数对象的实现，在整数对象的结构体<code>PyLongObject</code>定义中，使用到了<code>PyVarObject</code>，用于指定size。</li>
</ul>
<h2 id="3为什么pyobject要定义在每一个python对象的最开始字节中">3.为什么PyObject要定义在每一个Python对象的最开始字节中<a hidden class="anchor" aria-hidden="true" href="#3为什么pyobject要定义在每一个python对象的最开始字节中">#</a></h2>
<p>从<code>PyVarObject</code>的定义可以看出，<code>PyVarObject</code>只是<code>PyObject</code>的一个扩展而已。因此，对于任何一个<code>PyVarObject</code>，其所占用的内存，开始部分的字节的意义和<code>PyObject</code>是一样的。换句话说，在<code>Python</code>内部，每一个对象都拥有相同的对象头部。这就使得在<code>Python</code>中，对对象的引用变得非常统一，我们只需要用一个<code>PyObject*</code>指针就可以引用任意一个对象，而不论该对象实际是一个什么对象。</p>
<p>这是一个简单的转换示例程序：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PyObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">_ob</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">_type</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">PyVarObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyObject</span> <span class="n">ob_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ob_size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// List结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">PyListObject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyVarObject</span> <span class="n">ob_var</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">ob_item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Python中的双向链表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="n">refchain</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyListObject</span> <span class="n">list</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ob_var</span><span class="p">.</span><span class="n">ob_size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ob_var</span><span class="p">.</span><span class="n">ob_base</span><span class="p">.</span><span class="n">_ob</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ob_var</span><span class="p">.</span><span class="n">ob_base</span><span class="p">.</span><span class="n">_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="p">.</span><span class="n">ob_item</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyListObject</span> <span class="o">*</span><span class="n">p_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Object和List可以通过指针进行强转
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">p_ob</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PyObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">p_list</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Object: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">p_ob</span><span class="o">-&gt;</span><span class="n">_ob</span><span class="p">);</span> <span class="c1">// Object: 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">PyListObject</span> <span class="o">*</span><span class="n">p_list1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PyListObject</span> <span class="o">*</span><span class="p">)(</span><span class="n">p_ob</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;List: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">p_list1</span><span class="o">-&gt;</span><span class="n">ob_item</span><span class="p">);</span> <span class="c1">// List: 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="4类型对象">4.类型对象<a hidden class="anchor" aria-hidden="true" href="#4类型对象">#</a></h2>
<p>当在内存中分配空间，创建对象的时候，我们需要知道申请多大的空间。显然，这不是一个定值，因为不同的对象，需要不同的空间，一个整数对象和一个字符串对象所需的空间肯定不同。</p>
<p>在<code>PyObject</code>中，<code>PyTypeObject *ob_type</code>字段就表示类型对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">PyObject_VAR_HEAD</span>
</span></span><span class="line"><span class="cl">		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span>  <span class="cm">/* 用于打印，格式为&#34;&lt;moudle&gt;.&lt;name&gt;&#34; */</span>
</span></span><span class="line"><span class="cl">		<span class="n">Py_ssize_t</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span>  <span class="cm">/* For allocation */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="cm">/* Methods to implement standard operations */</span>
</span></span><span class="line"><span class="cl">    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="cm">/* Method suites for standard classes */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">PyNumberMethods</span> <span class="o">*</span><span class="n">tp_as_number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PySequenceMethods</span> <span class="o">*</span><span class="n">tp_as_sequence</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">PyMappingMethods</span> <span class="o">*</span><span class="n">tp_as_mapping</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一个<code>PyTypeObject</code>对象就是<code>Python</code>中面向对象理论中的”类“的实现。</p>
<p>在<code>PyTypeObject</code>的定义中，有三组非常重要的操作族，<code>tp_as_number、tp_as_sequence、tp_as_mapping</code>。它们分别指向<code>PyNumberMethods、PySequenceMethods、PyMappingMethods</code>函数族。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="n">PyObject</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">binaryfunc</span><span class="p">)(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">binaryfunc</span> <span class="n">nb_add</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">binaryfunc</span> <span class="n">nb_subtract</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">PyNumberMethods</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在<code>PyNumberMethods</code>中，定义了一个数值对象应该支持的操作。</p>
<p>对于一种类型来说，它完全可以同时定义三个函数中的所有操作。即一个对象既可以表现出数值对象的特性，也可以表现出map对象的特性。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="k">class</span> <span class="nc">Int</span><span class="p">(</span><span class="nb">int</span><span class="p">):</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>     <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>         <span class="k">return</span> <span class="n">key</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="p">[</span><span class="s2">&#34;key&#34;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;key1&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>a</code>是一个数值类型的对象实例，我们通过重写<code>__getitem__</code>方法，可以视为指定了<code>Int</code>在<code>Python</code>内部对应的<code>PyTypeObject</code>对象的<code>tp_as_mapping.mp_subcript</code>操作，最终<code>Int</code>的实例对象可以表现得像<code>map</code>对象一样。原因就是<code>PyTypeObject</code>允许一种类型同时指定三种不同对象的行为特性。</p>
<h2 id="5引用计数">5.引用计数<a hidden class="anchor" aria-hidden="true" href="#5引用计数">#</a></h2>
<p>类型对象是不会被析构的，因为没有人回去增加和减少类型对象的引用计数，<code>Python</code>程序启动后，类型对象就已经定义好了。</p>
<p>在每个对象创建的时候，<code>Python</code>会使用<code>_Py_NewReference(op)</code>宏来将对象的引用计数初始化为<code>1</code>。</p>
<p>当对象的引用计数等于<code>0</code>时，<code>Python</code>不一定会将内存空间释放，而是会采用内存缓冲池的机制，将不使用的对象缓存起来，增加<code>Python</code>的执行效率。我们后续介绍<code>Python</code>的缓冲机制。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://zzhaolei.github.io/tags/python/">Python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://zzhaolei.github.io/posts/python%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0python%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1/">
    <span class="title">« 上一页</span>
    <br>
    <span>Python源码笔记——Python中的整数对象</span>
  </a>
  <a class="next" href="https://zzhaolei.github.io/posts/mosh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E7%BB%88%E7%AB%AF%E9%A2%9C%E8%89%B2%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/">
    <span class="title">下一页 »</span>
    <br>
    <span>Mosh连接服务器时终端颜色显示问题</span>
  </a>
</nav>

  </footer><script
    src="https://giscus.app/client.js"
    data-repo="zzhaolei/zzhaolei.github.io"
    data-repo-id="R_kgDOMn_okw"
    data-category="Announcements"
    data-category-id="DIC_kwDOMn_ok84CiEHA"
    data-mapping="title"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async
></script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://zzhaolei.github.io/">lei的博客</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
