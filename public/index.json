[{"content":"Rust main 函数到底是如何被执行的呢？ 让我们看一个关于 main 函数的示例：\nuse std::error::Error; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { println!(\u0026#34;hello world\u0026#34;); Ok(()) } 从这个示例我们可以看到，rust 的 main 函数竟然还可以返回 Result 枚举，这是为什么？rust 到底是如何执行用户定义的 main 函数的呢？\n接下来让我们对 rust 的源码进行剖析，看一看 rust 到底是如何运行 main 函数的。\nRust 运行时 首先，在几乎所有的语言中（目前我不知道哪个语言会不进行处理），在执行用户的 main 函数之前都需要进行一些初始化工作，比如分配堆栈、创建并绑定主线程、初始化通用寄存器、初始化 GC等等。\n而 rust 也不例外，也会在实际调用用户执行的 main 之前进行一些初始化的操作。\n你没看错，rust 也是有运行时的，只不过这个运行时没有 GC，非常的轻量级，主要是执行上面所说的初始化操作以及对 main 函数的执行和收尾。\n让我们先从 init 开始：\n// 在执行 main 之前执行 unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) { #[cfg_attr(target_os = \u0026#34;teeos\u0026#34;, allow(unused_unsafe))] unsafe { // 实际的资源初始化逻辑 sys::init(argc, argv, sigpipe) }; // 设置主线程，并设置一个名字 let thread = Thread::new_main(); thread::set_current(thread); } // 运行时只会执行一次 cleanup。 // 在 main 或程序退出的时候执行 // NOTE: 当程序被终止的时候，不能保证执行 cleanup // （终止是 kill 等强制终止，或段错误等行为，程序无法继续执行，资源由操作系统进行回收） pub(crate) fn cleanup() { static CLEANUP: Once = Once::new(); CLEANUP.call_once(|| unsafe { // 刷新 stdout 缓冲区的数据，并禁用缓冲区 crate::io::cleanup(); // SAFETY: 通过 Once 保证，只会执行一次 cleanup sys::cleanup(); }); } 系统资源的初始化和清理在 sys::init 和 sys::cleanup 中 sys::init 在 ffi 中不保证被调用 sys::init 的源码不是算复杂，主要是保证打开标准输入输出流、初始化栈，感兴趣的可以自行阅读源码 现在我们终于可以进入重点了，rust 对 main 函数的处理逻辑：\n#[lang = \u0026#34;start\u0026#34;] fn lang_start\u0026lt;T: crate::process::Termination + \u0026#39;static\u0026gt;( main: fn() -\u0026gt; T, argc: isize, argv: *const *const u8, sigpipe: u8 ) -\u0026gt; isize { let Ok(v) = lang_start_internal( \u0026amp;(move || crate::sys::backtrace::__rust_begin_short_backtrace(main).report().to_i32()), argc, argv, sigpipe ); v } fn lang_start_internal( main: \u0026amp;(dyn (Fn() -\u0026gt; i32) + Sync + crate::panic::RefUnwindSafe), argc: isize, argv: *const *const u8, sigpipe: u8 ) -\u0026gt; Result\u0026lt;isize, !\u0026gt; { use crate::{ mem, panic }; let rt_abort = move |e| { mem::forget(e); rtabort!(\u0026#34;initialization or cleanup bug\u0026#34;); }; // 初始化参数、栈等信息，并捕获可能的异常信息，展开异常的栈调用路径 panic::catch_unwind(move || unsafe { init(argc, argv, sigpipe) }).map_err(rt_abort)?; // 调用用户定义的 main 函数 // 这里会尝试获取用户返回的 exitcode，通过 Termination::report let ret_code = panic ::catch_unwind(move || panic::catch_unwind(main).unwrap_or(101) as isize) .map_err(move |e| { mem::forget(e); rtabort!(\u0026#34;drop of the panic payload panicked\u0026#34;); }); // 执行清理程序 panic::catch_unwind(cleanup).map_err(rt_abort)?; // 退出主线程 panic::catch_unwind(|| crate::sys::exit_guard::unique_thread_exit()).map_err(rt_abort)?; ret_code } 让我们一步步分析 lang_start 函数：\n在 lang_start 中我们可以看到这个函数被标记了 #[lang = \u0026quot;start\u0026quot;] 这表明是语言的入口函数。\nlang_start 本质是调用的 lang_start_internal ，在 lang_start_internal 中对资源进行初始化、执行 main、清理资源。\n我们可以看到 lang_start 函数的参数有一个 main，而 main 的类型是一个函数，类型声明为 fn() → T，T 的约束是 T: crate::process::Termination + 'static ，对于我们这次分析来说，最重要的是 trait Termination 。\nTermination 相关签名（删除了一些属性宏，不影响理解）：\n#[derive(PartialEq, Eq, Clone, Copy)] pub struct ExitCode(u8); impl ExitCode { pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _); pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _); #[inline] pub fn as_i32(\u0026amp;self) -\u0026gt; i32 { self.0 as i32 } } impl From\u0026lt;u8\u0026gt; for ExitCode { fn from(code: u8) -\u0026gt; Self { Self(code) } } pub trait Termination { /// Is called to get the representation of the value as status code. /// This status code is returned to the operating system. #[stable(feature = \u0026#34;termination_trait_lib\u0026#34;, since = \u0026#34;1.61.0\u0026#34;)] fn report(self) -\u0026gt; ExitCode; } 现在我们的疑问有了答案，是因为 Result 枚举实现了 Termination，所以用户定义的 main 函数可以返回 Result 枚举：\n#[stable(feature = \u0026#34;termination_trait_lib\u0026#34;, since = \u0026#34;1.61.0\u0026#34;)] impl\u0026lt;T: Termination, E: fmt::Debug\u0026gt; Termination for Result\u0026lt;T, E\u0026gt; { fn report(self) -\u0026gt; ExitCode { match self { Ok(val) =\u0026gt; val.report(), Err(err) =\u0026gt; { io::attempt_print_to_stderr(format_args_nl!(\u0026#34;Error: {err:?}\u0026#34;)); ExitCode::FAILURE } } } } 通过代码 crate::sys::backtrace::__rust_begin_short_backtrace(main).report().to_i32() 可以看到，实际调用了 main 返回值的 report 函数，也就是 Result::report，这会返回一个 i32 值，用于标识程序是否正常退出。 __rust_begin_short_backtrace 实际就是一个包装函数，用于防止尾部调用优化的。 新的问题又出现了 最开始的问题解决了，但是我们又想到了一个新的问题。\n既然 rust 的 lang_start 需要一个 fn → T, T: crate::process::Termination + 'static 的类型约束，为什么 main 函数什么也不返回也可以呢？\n看这个示例：\nfn main() { println!(\u0026#34;hello world!\u0026#34;); } 回答这个问题，我们首先要知道，在 rust 中函数什么也没返回的情况下，其实也是有返回的，只是可以省略不写而已，上面示例的实际脱糖（剥离语法糖）形式为：\nfn main() -\u0026gt; () { println!(\u0026#34;hello world!\u0026#34;); } 即：默认会返回一个()，实际类型名字叫做 unit ，中文一般称作单元类型。\n恰好，unit 类型，也实现了 Termination trai，所以 main 函数什么也不返回也是可以的。\n#[stable(feature = \u0026#34;termination_trait_lib\u0026#34;, since = \u0026#34;1.61.0\u0026#34;)] impl Termination for () { #[inline] fn report(self) -\u0026gt; ExitCode { ExitCode::SUCCESS } } 并且 Termination::report 签名要求返回一个 ExitCode，而 ExitCode 又实现了 From\u0026lt;u8\u0026gt;，所以实际上还可以在 main 函数中返回一个 u8 的数字。\n例如：\nuse std::process::ExitCode; fn main() -\u0026gt; ExitCode { println!(\u0026#34;hello world!\u0026#34;); 0.into() // program success } 还可以自定义返回类型，只要实现了 Termination 即可，下面是一个示例：\nuse std::process::{ExitCode, Termination}; struct MyExit { msg: String, } impl MyExit { fn new(msg: String) -\u0026gt; Self { MyExit { msg } } } impl Termination for MyExit { fn report(self) -\u0026gt; ExitCode { if self.msg.eq(\u0026#34;ok\u0026#34;.into()) { 0.into() } else { 1.into() } } } fn main() -\u0026gt; MyExit { let exit = MyExit::new(\u0026#34;ok\u0026#34;.into()); exit } 补充资料 rust 的 lang_start 也是被调用者，是调用的它呢？在 rust 中有一个 create_entry_fn 负责创建 entry 函数，这个函数中会调用 lang_start 函数。源码。 在裸机开发中（no_std），通常 main 函数是不会返回的，所以是没有 exitcode 的。 ","permalink":"http://localhost:1313/posts/rust-main-%E5%87%BD%E6%95%B0%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84/","summary":"Rust main 函数到底是如何被执行的呢？ 让我们看一个关于 main 函数的示例：\nuse std::error::Error; fn main() -\u0026gt; Result\u0026lt;(), Box\u0026lt;dyn Error\u0026gt;\u0026gt; { println!(\u0026#34;hello world\u0026#34;); Ok(()) } 从这个示例我们可以看到，rust 的 main 函数竟然还可以返回 Result 枚举，这是为什么？rust 到底是如何执行用户定义的 main 函数的呢？\n接下来让我们对 rust 的源码进行剖析，看一看 rust 到底是如何运行 main 函数的。\nRust 运行时 首先，在几乎所有的语言中（目前我不知道哪个语言会不进行处理），在执行用户的 main 函数之前都需要进行一些初始化工作，比如分配堆栈、创建并绑定主线程、初始化通用寄存器、初始化 GC等等。\n而 rust 也不例外，也会在实际调用用户执行的 main 之前进行一些初始化的操作。\n你没看错，rust 也是有运行时的，只不过这个运行时没有 GC，非常的轻量级，主要是执行上面所说的初始化操作以及对 main 函数的执行和收尾。\n让我们先从 init 开始：\n// 在执行 main 之前执行 unsafe fn init(argc: isize, argv: *const *const u8, sigpipe: u8) { #[cfg_attr(target_os = \u0026#34;teeos\u0026#34;, allow(unused_unsafe))] unsafe { // 实际的资源初始化逻辑 sys::init(argc, argv, sigpipe) }; // 设置主线程，并设置一个名字 let thread = Thread::new_main(); thread::set_current(thread); } // 运行时只会执行一次 cleanup。 // 在 main 或程序退出的时候执行 // NOTE: 当程序被终止的时候，不能保证执行 cleanup // （终止是 kill 等强制终止，或段错误等行为，程序无法继续执行，资源由操作系统进行回收） pub(crate) fn cleanup() { static CLEANUP: Once = Once::new(); CLEANUP.","title":"Rust Main 函数是如何被执行的"},{"content":"go 本身提供的 semaphore 只能在同一个进程多个协程或线程间使用，无法在不同的 go 进程之间使用，所以本文介绍，如何使用 go 中的 syscall 来使用 POSIX 系统提供的命名信号量。\nGo 中的系统调用 在 go 中，系统调用是通过 syscall 包提供的 Syscall 函数来进行系统调用的，不同的系统调用有不同的 trap，以及不同长度的参数。\ntrap go 在 syscall 包中定义了大量的系统调用码，具体定义在文件1.20.6/go/src/syscall/zsysnum_darwin_arm64.go 。不同操作系统上，定义所使用的文件是不同的，这些定义都是通过不同系统的c 语言头文件自动生成的。比如 linux amd64 操作系统的定义在1.20.6/go/src/syscall/zerrors_linux_amd64.go。\n不同长度的参数 syscall 包有 Syscall、Syscall6 两个函数，对应于不同的操作系统调用参数长度的情况。\nSyscall 总共接收 4 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 3 个是系统调用所需的参数。\nSyscall6 总共接收 7 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 6 个是系统调用所需的参数。\n如果使用 Syscall 或 Syscall6 时，系统调用所需的参数不满足函数形参所需的数量，则剩下的参数传0。\n例如，在 POSIX 系统上打开一个命名信号量的系统调用是:\nsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); 因为系统调用的参数有 4 个，而 Syscall 接收的全部形参才 4 个，所以 Syscall 不能满足我们的需求，只能使用 Syscall6 这个函数。而 Syscall6 总共需要 7 个形参，其中有 6 个是系统调用参数，我们只有 4 个系统调用参数，那么剩下的 2 个系统调用参数，我们就可以使用 0 替代，例如：\nr1, r2, err := syscall.Syscall6( syscall.SYS_SEM_OPEN, uintptr(unsafe.Pointer(cs)), // name uintptr(C.O_CREAT), // flag uintptr(mode), // mode uintptr(value), // value 0, // 没有更多参数，使用 0 0, ) 实现Samephore 信号量的操作主要有这么几个系统调用：sem_open、sem_wait、sem_trywait、sem_post、sem_close、sem_unlink。\n在具体实现之前，我们先引入 C 头文件和定义一些结构，方便我们后续使用。\n我们可以创建一个 semaphore/semaphore.go 的包，然后在 semaphore.go 中添加下面的代码：\npackage semaphore /* #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; */ import \u0026#34;C\u0026#34; import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;unsafe\u0026#34; ) // Semaphore 是一个用来保存 信号描述符 的结构体 type Semaphore struct { sd uintptr } // New 创建一个空的信号量结构体 func New() *Semaphore { return \u0026amp;Semaphore{} } 下文中涉及到的 Go 代码，均在 semaphore.go 文件中。\nsem_open POSIX 系统调用：\n#include \u0026lt;semaphore.h\u0026gt; sem_t * sem_open(const char *name, int oflag, mode_t mode, unsigned int value); 获取一个 sem_t 值，这个值就是一个文件描述符，代表一个被打开的信号量。\nGo 调用：\nfunc (sem *Semaphore) Open(name string, mode int, value int) error { // 将 go 字符串转为 C 字符串 cs := C.CString(name) // C.CString 会在 C 侧重新申请内存，所以需要在使用后释放(在 stdlib.h 中) defer C.free(unsafe.Pointer(cs)) // 调用 sem_open 系统调用，传递必须参数 // C.O_CREAT 表示创建(在 fcntl.h 中)，value 是信号量的值，mode 为打开的 信号描述符 的状态 r1, _, err := syscall.Syscall6( syscall.SYS_SEM_OPEN, uintptr(unsafe.Pointer(cs)), uintptr(C.O_CREAT), uintptr(mode), uintptr(value), 0, 0, ) if err != 0 { sem.Unlink(name) return fmt.Errorf(\u0026#34;create semaphore failed: %s\u0026#34;, err) } sem.sd = r1 return nil } sem_trywait 和 sem_wait POSIX 系统调用：\n#include \u0026lt;semaphore.h\u0026gt; int sem_trywait(sem_t *sem); int sem_wait(sem_t *sem); sem_trywait 当 sem 的值为 0 时，此操作不会阻塞等待，而是会立即返回。\nsem_wait 当 sem 的值为 0 时，此操作会阻塞等待，直到能获取信号量或者调用被中断。\n这两个操作都会 locked sem，并且操作结果相当于 sem 值减一。\nGo 调用：\nfunc (sem *Semaphore) TryAcquire() error { _, _, err := syscall.Syscall(syscall.SYS_SEM_TRYWAIT, sem.sd, 0, 0) if err != 0 { return fmt.Errorf(\u0026#34;try acquire failed: %s\u0026#34;, err.Error()) } return nil } func (sem *Semaphore) Acquire() { _, _, _ = syscall.Syscall(syscall.SYS_SEM_WAIT, sem.sd, 0, 0) } sem_post POSIX 系统调用：\n#include \u0026lt;semaphore.h\u0026gt; int sem_post(sem_t *sem); locked sem，对 sem 值加一，并且等待该信号量的所有进程/线程都会被唤醒。\nGo 调用：\nfunc (sem *Semaphore) Release() { _, _, _ = syscall.Syscall(syscall.SYS_SEM_POST, sem.sd, 0, 0) } sem_close 和 sem_unlink POSIX 系统调用：\n#include \u0026lt;semaphore.h\u0026gt; int sem_close(sem_t *sem); int sem_unlink(const char *name); sem_close：所引用的命名信号量关联的系统内存资源被释放，描述符无效。\nsem_unlink：移除名为 name 的命名信号量。如果该信号量正在被其他进程使用，那么 name 将立即与该信号量解除关联，但是该信号量本身不会被移除，直到对它的所有引用都被关闭。使用 name 对 sem_open() 的后续调用将引用或创建一个名为 name 的新信号量。\nGo 调用：\nfunc (sem *Semaphore) Unlink(name string) { cs := C.CString(name) defer C.free(unsafe.Pointer(cs)) sem.close() _, _, _ = syscall.Syscall(syscall.SYS_SEM_UNLINK, uintptr(unsafe.Pointer(cs)), 0, 0) } func (sem *Semaphore) close() { _, _, _ = syscall.Syscall(syscall.SYS_SEM_CLOSE, sem.sd, 0, 0) } ","permalink":"http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E5%9C%A8go%E4%B8%AD%E4%BD%BF%E7%94%A8posix%E5%91%BD%E5%90%8D%E4%BF%A1%E5%8F%B7%E9%87%8F/","summary":"go 本身提供的 semaphore 只能在同一个进程多个协程或线程间使用，无法在不同的 go 进程之间使用，所以本文介绍，如何使用 go 中的 syscall 来使用 POSIX 系统提供的命名信号量。\nGo 中的系统调用 在 go 中，系统调用是通过 syscall 包提供的 Syscall 函数来进行系统调用的，不同的系统调用有不同的 trap，以及不同长度的参数。\ntrap go 在 syscall 包中定义了大量的系统调用码，具体定义在文件1.20.6/go/src/syscall/zsysnum_darwin_arm64.go 。不同操作系统上，定义所使用的文件是不同的，这些定义都是通过不同系统的c 语言头文件自动生成的。比如 linux amd64 操作系统的定义在1.20.6/go/src/syscall/zerrors_linux_amd64.go。\n不同长度的参数 syscall 包有 Syscall、Syscall6 两个函数，对应于不同的操作系统调用参数长度的情况。\nSyscall 总共接收 4 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 3 个是系统调用所需的参数。\nSyscall6 总共接收 7 个参数，第一个是 trap 定义，描述具体的系统调用，剩下的 6 个是系统调用所需的参数。\n如果使用 Syscall 或 Syscall6 时，系统调用所需的参数不满足函数形参所需的数量，则剩下的参数传0。\n例如，在 POSIX 系统上打开一个命名信号量的系统调用是:\nsem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value); 因为系统调用的参数有 4 个，而 Syscall 接收的全部形参才 4 个，所以 Syscall 不能满足我们的需求，只能使用 Syscall6 这个函数。而 Syscall6 总共需要 7 个形参，其中有 6 个是系统调用参数，我们只有 4 个系统调用参数，那么剩下的 2 个系统调用参数，我们就可以使用 0 替代，例如：","title":"如何在Go中使用POSIX命名信号量"},{"content":"","permalink":"http://localhost:1313/tags/","summary":"tags","title":"Tag"}]